package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"bookstore-api/graph"
	"bookstore-api/graph/generated"
	"bookstore-api/internal/models"
	"bookstore-api/internal/repository"
	"context"
	"fmt"
	"strconv"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, username string, email string, password string, role string) (*graph.User, error) {
	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	user := models.User{
		Username:     username,
		Email:        email,
		PasswordHash: string(hashedPassword),
		Role:         role,
	}

	if err := repository.CreateUser(user); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Get the inserted user to get ID
	createdUser, err := repository.GetUserByEmail(email)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch created user: %w", err)
	}

	return &graph.User{
		ID:       strconv.Itoa(createdUser.ID),
		Username: createdUser.Username,
		Email:    createdUser.Email,
		Role:     createdUser.Role,
	}, nil
}

// CreateAuthor is the resolver for the createAuthor field.
func (r *mutationResolver) CreateAuthor(ctx context.Context, name string, bio *string) (*graph.Author, error) {
	author := &models.Author{
		Name: name,
	}

	if bio != nil {
		author.Bio = *bio
	}

	if err := repository.CreateAuthor(author); err != nil {
		return nil, fmt.Errorf("failed to create author: %w", err)
	}

	return &graph.Author{
		ID:   strconv.Itoa(author.ID),
		Name: author.Name,
		Bio:  &author.Bio,
	}, nil
}

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, title string, authorID string, publishedYear *int, genre *string, page *int) (*graph.Book, error) {
	// Convert authorID from string (GraphQL) to int
	authorIDInt, err := strconv.Atoi(authorID)
	if err != nil {
		return nil, fmt.Errorf("invalid authorID: %w", err)
	}

	// Create Book model
	book := &models.Book{
		Title:         title,
		AuthorID:      authorIDInt,
		PublishedYear: 0,
		Genre:         "",
		Page:          0,
	}

	if publishedYear != nil {
		book.PublishedYear = *publishedYear
	}
	if genre != nil {
		book.Genre = *genre
	}
	if page != nil {
		book.Page = *page
	}

	// Insert into DB
	err = repository.CreateBook(book)
	if err != nil {
		return nil, fmt.Errorf("failed to create book: %w", err)
	}

	// Fetch author info for GraphQL response
	author, err := repository.GetAuthorByID(book.AuthorID)
	if err != nil {
		return nil, fmt.Errorf("failed to get author info: %w", err)
	}

	// Return GraphQL book type
	return &graph.Book{
		ID:    fmt.Sprint(book.ID),
		Title: book.Title,
		Author: &graph.Author{
			ID:   fmt.Sprint(author.ID),
			Name: author.Name,
			Bio:  &author.Bio,
		},
		PublishedYear: &book.PublishedYear,
		Genre:         &book.Genre,
		Page:          &book.Page,
	}, nil
}

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, bookID string, userID int, text *string, rating *int) (*graph.Review, error) {
	// Parse book UUID
	bookUUID, err := uuid.Parse(bookID)
	if err != nil {
		return nil, fmt.Errorf("invalid book ID: %w", err)
	}

	// Create the review model
	review := &models.Review{
		BookID: bookUUID,
		UserID: userID,
		Text:   "",
		Rating: 0,
	}

	if text != nil {
		review.Text = *text
	}
	if rating != nil {
		review.Rating = *rating
	}

	// Insert into DB
	err = repository.CreateReview(review)
	if err != nil {
		return nil, fmt.Errorf("failed to create review: %w", err)
	}

	// Fetch book and user to return in GraphQL type
	book, err := repository.GetBookByID(bookUUID)
	if err != nil {
		return nil, err
	}

	user, err := repository.GetUserByID(userID)
	if err != nil {
		return nil, err
	}

	return &graph.Review{
		ID:     review.ID.String(),
		Book:   &graph.Book{ID: book.ID.String(), Title: book.Title}, // simplify author if needed
		User:   &graph.User{ID: strconv.Itoa(user.ID), Username: user.Username, Email: user.Email, Role: user.Role},
		Text:   &review.Text,
		Rating: &review.Rating,
	}, nil
}

// GetUserByID is the resolver for the getUserByID field.
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*graph.User, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}
	u, err := repository.GetUserByID(intID)
	if err != nil {
		return nil, err
	}
	return &graph.User{
		ID:       strconv.Itoa(u.ID),
		Username: u.Username,
		Email:    u.Email,
		Role:     u.Role,
	}, nil
}

// GetUserByEmail is the resolver for the getUserByEmail field.
func (r *queryResolver) GetUserByEmail(ctx context.Context, email string) (*graph.User, error) {
	u, err := repository.GetUserByEmail(email)
	if err != nil {
		return nil, err
	}
	return &graph.User{
		ID:       strconv.Itoa(u.ID),
		Username: u.Username,
		Email:    u.Email,
		Role:     u.Role,
	}, nil
}

// ListUsers is the resolver for the listUsers field.
func (r *queryResolver) ListUsers(ctx context.Context) ([]*graph.User, error) {
	users, err := repository.ListUsers()
	if err != nil {
		return nil, err
	}
	var result []*graph.User
	for _, u := range users {
		result = append(result, &graph.User{
			ID:       strconv.Itoa(u.ID),
			Username: u.Username,
			Email:    u.Email,
			Role:     u.Role,
		})
	}
	return result, nil
}

// GetAuthorByID is the resolver for the getAuthorByID field.
func (r *queryResolver) GetAuthorByID(ctx context.Context, id string) (*graph.Author, error) {
	intID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid author ID: %w", err)
	}
	a, err := repository.GetAuthorByID(intID)
	if err != nil {
		return nil, err
	}
	return &graph.Author{
		ID:   strconv.Itoa(a.ID),
		Name: a.Name,
		Bio:  &a.Bio,
	}, nil
}

// ListAuthors is the resolver for the listAuthors field.
func (r *queryResolver) ListAuthors(ctx context.Context) ([]*graph.Author, error) {
	authors, err := repository.ListAuthors()
	if err != nil {
		return nil, err
	}
	var result []*graph.Author
	for _, a := range authors {
		bio := a.Bio
		result = append(result, &graph.Author{
			ID:   strconv.Itoa(a.ID),
			Name: a.Name,
			Bio:  &bio,
		})
	}
	return result, nil
}

// GetBookByID is the resolver for the getBookByID field.
func (r *queryResolver) GetBookByID(ctx context.Context, id string) (*graph.Book, error) {
	// Convert book ID from string to UUID
	bookUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid book ID: %w", err)
	}

	// Fetch the book from DB
	b, err := repository.GetBookByID(bookUUID)
	if err != nil {
		return nil, err
	}

	// Fetch the author using AuthorID (direct int)
	a, err := repository.GetAuthorByID(b.AuthorID)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL Book type
	return &graph.Book{
		ID:    b.ID.String(),
		Title: b.Title,
		Author: &graph.Author{
			ID:   strconv.Itoa(a.ID),
			Name: a.Name,
			Bio:  &a.Bio,
		},
		PublishedYear: &b.PublishedYear,
		Genre:         &b.Genre,
		Page:          &b.Page,
	}, nil
}

// ListBooks is the resolver for the listBooks field.
func (r *queryResolver) ListBooks(ctx context.Context) ([]*graph.Book, error) {
	// Fetch all books from DB
	books, err := repository.ListBooks()
	if err != nil {
		return nil, err
	}

	var result []*graph.Book
	for _, b := range books {
		// Fetch the author using AuthorID
		a, err := repository.GetAuthorByID(b.AuthorID)
		if err != nil {
			return nil, err
		}

		// Map to GraphQL Book type
		book := &graph.Book{
			ID:    b.ID.String(),
			Title: b.Title,
			Author: &graph.Author{
				ID:   strconv.Itoa(a.ID),
				Name: a.Name,
				Bio:  &a.Bio,
			},
			PublishedYear: &b.PublishedYear,
			Genre:         &b.Genre,
			Page:          &b.Page,
		}
		result = append(result, book)
	}

	return result, nil
}

// GetReviewByID is the resolver for the getReviewByID field.
func (r *queryResolver) GetReviewByID(ctx context.Context, id string) (*graph.Review, error) {
	reviewUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid review ID: %w", err)
	}
	review, err := repository.GetReviewByID(reviewUUID)
	if err != nil {
		return nil, err
	}

	book, err := repository.GetBookByID(review.BookID)
	if err != nil {
		return nil, err
	}

	user, err := repository.GetUserByID(int(review.UserID))
	if err != nil {
		return nil, err
	}

	return &graph.Review{
		ID:     review.ID.String(),
		Book:   &graph.Book{ID: book.ID.String(), Title: book.Title},
		User:   &graph.User{ID: strconv.Itoa(user.ID), Username: user.Username, Email: user.Email, Role: user.Role},
		Text:   &review.Text,
		Rating: &review.Rating,
	}, nil
}

// ListReviews is the resolver for the listReviews field.
func (r *queryResolver) ListReviews(ctx context.Context) ([]*graph.Review, error) {
	reviews, err := repository.ListReviews()
	if err != nil {
		return nil, err
	}
	var result []*graph.Review
	for _, review := range reviews {
		book, err := repository.GetBookByID(review.BookID)
		if err != nil {
			return nil, err
		}
		user, err := repository.GetUserByID(int(review.UserID))
		if err != nil {
			return nil, err
		}
		result = append(result, &graph.Review{
			ID:     review.ID.String(),
			Book:   &graph.Book{ID: book.ID.String(), Title: book.Title},
			User:   &graph.User{ID: strconv.Itoa(user.ID), Username: user.Username, Email: user.Email, Role: user.Role},
			Text:   &review.Text,
			Rating: &review.Rating,
		})
	}
	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
